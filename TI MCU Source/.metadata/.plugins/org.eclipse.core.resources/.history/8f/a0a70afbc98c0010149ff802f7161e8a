/** @file sys_main.c 
*   @brief Application main file
*   @date 11-Dec-2018
*   @version 04.07.01
*
*   This file contains an empty main function,
*   which can be used for the application.
*/

/* 
* Copyright (C) 2009-2018 Texas Instruments Incorporated - www.ti.com 
* 
* 
*  Redistribution and use in source and binary forms, with or without 
*  modification, are permitted provided that the following conditions 
*  are met:
*
*    Redistributions of source code must retain the above copyright 
*    notice, this list of conditions and the following disclaimer.
*
*    Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the 
*    documentation and/or other materials provided with the   
*    distribution.
*
*    Neither the name of Texas Instruments Incorporated nor the names of
*    its contributors may be used to endorse or promote products derived
*    from this software without specific prior written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
*  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
*  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
*  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
*/


/* USER CODE BEGIN (0) */

/* OS INCLUDES */
#include "FreeRTOS.h"
#include "os_task.h"
#include "os_queue.h"

/* HW INCLUDES */
#include "gio.h"
#include "het.h"
#include "adc.h"
#include "spi.h"
#include "sci.h"

/* DRIVER INCLUDES */
#include "projlib/HX711_FREERTOS.h"
#include "projlib/BLDC_ctrlLib.h"
#include "projlib/CROSSCHANNEL.h"
#include "embedded_SCADE/SCADE_global_lib.h"

/* USER CODE END */

/* Include Files */

#include "sys_common.h"

/* USER CODE BEGIN (1) */

/* C COMMON INCLUDES */
#include <stdio.h>
#include <stdlib.h>

/* USER DEFINES BEGIN */
#define GAUGE_1_MAX_THRTT   233975
#define GAUGE_1_MIN_THRTT   156838
#define GAUGE_2_MAX_THRTT  -32419
#define GAUGE_2_MIN_THRTT  -108097

#define HX711_USER_RES  HX711_RES_128R_A

_ECU_MODE BOARDMODE;
/* USER DEFINES END */

/* USER TASKS BEGIN */
/* TASK MASTER */
void vTaskMASTER(void *pvParameters);
TaskHandle_t xTaskMASTER;

/* BLDC Control */
void vTask_MotorCtrl(void *pvParameters);
TaskHandle_t xTask_MotorCtrl_Handle;

/* Cross Channel Comm */
void vTask_CrossCh_Comm(void *pvParameters);
TaskHandle_t xTask_CrossCh_Comm_Handle;

/* Serial Panel Comm*/
void vTask_Srial_Comms(void *pvParameters);
TaskHandle_t xTask_Srial_Comms_Handle;

/* HX711 Polling */
void vTask_HX711_Poll(void *pvParameters);
TaskHandle_t xTask_HX711_Poll_Handle;
/* USER TASKS END */

/* USER QUEUES BEGIN */
QueueHandle_t xQueue_SrialComm_HX711;       // HX711 telemetry queue
QueueHandle_t xQueue_CrossChComm_HX711;     // HX711 cross-channel Queue
QueueHandle_t xQueue_SrialComm_CtrlRef;     // Control throttle telemetry queue
QueueHandle_t xQueue_CrossChComm_CtrlRef;   // Control throttle cross-channel queue
/* USER QUEUES END */

/* GLOBALS BEGIN */
/* GLOBALS END */
/* USER CODE END */

/** @fn void main(void)
*   @brief Application main function
*   @note This function is empty by default.
*
*   This function is called after startup.
*   The user can use this function to implement the application.
*/

/* USER CODE BEGIN (2) */
HX711Data_t Local_Min_Gauge = GAUGE_2_MIN_THRTT;
HX711Data_t Local_Max_Gauge = GAUGE_2_MAX_THRTT;
/* USER CODE END */

int main(void)
{
/* USER CODE BEGIN (3) */
    /* HW Driver Init */
    gioInit();
    hetInit();
    adcInit();
    spiInit();
    sciInit();

    /* Initialize SCADE code */
    SCADEInit();

    /* HW Cross channel INIT */
    BOARDMODE = (gioGetBit(gioPORTA, 4U) == 0U) ? BOARD_BACKUP : BOARD_MAIN;    // Determine if board is MAIN or BACKUP
    if(BOARDMODE == BOARD_BACKUP)                                               // Switch backup MCU's SPI to Slave mode
    {
        /** SPI3 slave mode and clock configuration */
        spiREG3->GCR1 = (spiREG3->GCR1 & 0xFFFFFFFCU) | ((uint32)((uint32)0U << 1U)  /* CLOKMOD */
                      | 0U);  /* MASTER -> slave mode */
    }

    /* User Queues CREATE */
    xQueue_HX711_CtrlData = xQueueCreate(1, sizeof(HX711Data_t));           xQueueReset(xQueue_HX711_CtrlData);
    xQueue_HX711_Raw = xQueueCreate(1, sizeof(HX711Buff_t));            xQueueReset(xQueue_HX711_Raw);
    xQueue_CrossChComm_HX711 = xQueueCreate(1, sizeof(HX711Data_t));    xQueueReset(xQueue_CrossChComm_HX711);
    xQueue_CrossChComm_CtrlRef = xQueueCreate(1, sizeof(float32));      xQueueReset(xQueue_CrossChComm_CtrlRef);

    if(BOARDMODE == BOARD_MAIN)     // Main boards creates telemetry queues
    {
        xQueue_SrialComm_HX711 = xQueueCreate(2, sizeof(HX711Data_t));  xQueueReset(xQueue_SrialComm_HX711);
        xQueue_SrialComm_CtrlRef = xQueueCreate(2, sizeof(float32));    xQueueReset(xQueue_SrialComm_CtrlRef);
    }

    /* Default TASK MASTER */
    MPU_xTaskCreate(vTaskMASTER,                    // Task Function
                    "Master task",                  // PC Task Name
                    3 * configMINIMAL_STACK_SIZE,   // Memory Stack Size
                    NULL,                           // Task Parameters
                    5,                               // Priority
                    &xTaskMASTER);                  // Task Handler (xTaskHandle)

    /* Scheduler START */
    vTaskStartScheduler();

    for(;;);
/* USER CODE END */

    return 0;
}


/* USER CODE BEGIN (4) */

/* USER TASKS IMP, BEGIN */
void vTaskMASTER(void *pvParameters)
{
    ARINC_Frame_Mdata CommsDataIn, CommsDataOut;
    int32_t CommDATA, CommDATAIn;
    char CmdMsgBuff[65];

    // Set SDI for communications
    if(BOARDMODE == BOARD_MAIN)
        CommsDataOut.SDI = ARINC_SDI_Main;
    else
        CommsDataOut.SDI = ARINC_SDI_Backup;

    /* SYSTEM Init BEGIN */
    // Main - Backup acknowledge routine
    if(BOARDMODE == BOARD_MAIN)
    {
        sciSend(scilinREG, sprintf(CmdMsgBuff, "Main is waiting for backup acknowledge...\r\n"), (uint8 *) CmdMsgBuff);
        CrossChReceiveInt(&CommsDataIn, &CommDATAIn, false);
        if(CommsDataIn.LABEL == ARINC_LABEL_BackupAcknowledge)
            sciSend(scilinREG, sprintf(CmdMsgBuff, "Backup has acknowledged!\r\n"), (uint8 *) CmdMsgBuff);
        else
            while(1);       // BACKUP ACKNOWLEDGE ERROR
    }
    else
    {
        CommsDataOut.LABEL = ARINC_LABEL_BackupAcknowledge;
        CommsDataOut.SSM = ARINC_SSM_FnTest;
        CrossChTransmitInt(CommsDataOut, ARINC_DATA_DEFAULT);
    }

    sciSend(scilinREG, sprintf(CmdMsgBuff, "Starting OS\r\n"), (uint8 *) CmdMsgBuff);
    /* SYSTEM Init END */

    /* OS Init BEGIN */
    /* BLDC Controller Task CREATE */
    MPU_xTaskCreate(vTask_MotorCtrl,                // Task Code
                    "BLDC Control Task",            // HL Task Name
                    configMINIMAL_STACK_SIZE,       // Memory Stack Size
                    NULL,                           // Task Parameters
                    3,                              // Priority
                    &xTask_MotorCtrl_Handle);       // Task Handler (xTaskHandle)

    // BLDC Controller Task must notify
    MPU_ulTaskNotifyTake(pdTRUE, portMAX_DELAY);

    /* Cross Channel Comm Task CREATE */
    MPU_xTaskCreate(vTask_CrossCh_Comm,             // Task Code
                    "Cross channel Comms Task",     // HL Task Name
                    2 * configMINIMAL_STACK_SIZE,   // Memory Stack Size
                    NULL,                           // Task Parameters
                    2,                              // Priority
                    &xTask_CrossCh_Comm_Handle);    // Task Handler (xTaskHandle)

    // Cross Channel Comm Task must notify
    MPU_ulTaskNotifyTake(pdTRUE, portMAX_DELAY);

    if(BOARDMODE == BOARD_MAIN)     // Only main board transmits serial data
    {
        /* Control panel serial comm Task CREATE */
        MPU_xTaskCreate(vTask_Srial_Comms,              // Task Code
                        "Comm 2 Ctrl Panel Task",       // HL Task Name
                        3 * configMINIMAL_STACK_SIZE,   // Memory Stack Size
                        NULL,                           // Task Parameters
                        1,                              // Priority
                        &xTask_Srial_Comms_Handle);     // Task Handler (xTaskHandle)

        // Serial Comm Task must notify
        MPU_ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
    }

    /**
     *  Devices must be synced to begin reading their respecive sensors.
     */

    sciSend(scilinREG, sprintf(CmdMsgBuff, "Syncing devices...\r\n"), (uint8 *) CmdMsgBuff);

    /* HX711 Sensor Handler Task CREATE */
    MPU_xTaskCreate(vTask_HX711_Poll,               // Task Code
                    "HX711 Handler Task",           // HL Task Name
                    3 * configMINIMAL_STACK_SIZE,   // Memory Stack Size
                    NULL,                           // Task Parameters
                    4,                              // Priority
                    &xTask_HX711_Poll_Handle);      // Task Handler (xTaskHandle)

    // HX7111 Task must notify
    MPU_ulTaskNotifyTake(pdTRUE, portMAX_DELAY);

    if(BOARDMODE == BOARD_MAIN)
    {
        CommsDataOut.LABEL = ARINC_LABEL_MainHX711ready;
        CommsDataOut.SSM = ARINC_SSM_NormOp;
        CrossChTransmitInt(CommsDataOut, ARINC_DATA_DEFAULT);
        CrossChReceiveInt(&CommsDataIn, &CommDATA, false);
        if(CommsDataIn.LABEL == ARINC_LABEL_BackupHX711ready)
            sciSend(scilinREG, sprintf(CmdMsgBuff, "Devices Synced!...\r\n"), (uint8 *) CmdMsgBuff);
        else
            while(1);       // Backup OS init failed
    }
    else
    {
        CrossChReceiveInt(&CommsDataIn, &CommDATAIn, false);
        if(CommsDataIn.LABEL == ARINC_LABEL_MainHX711ready)
        {
            CommsDataOut.LABEL = ARINC_LABEL_BackupHX711ready;
            CommsDataOut.SSM = ARINC_SSM_NormOp;
            CrossChTransmitInt(CommsDataOut, ARINC_DATA_DEFAULT);
        }
        else
            while(1);       // Main OS init failed
    }
    CrossChTransmitandReceiveINT(&CommsDataIn, &CommDATAIn, CommsDataOut, ARINC_DATA_DEFAULT, false);
    xTaskNotifyGive(xTask_HX711_Poll_Handle);
    /* OS Init END */

    MPU_vTaskSuspend(NULL);     // Task Master END
}

void vTask_MotorCtrl(void *pvParameters)
{
    adcData_t ADC_CtrlData;
    HX711Data_t HX711_CtrlData;
    float32 ADCMotorThrtt;                          // Floating value for Pot-Set Throttle
    float32 MotCtrlRef, MotCtrlErr, MotCtrlSignl;   // Motor control signals

    /* Preliminary PID */
    float32 BLDC_PID[3] =
    {
     0.65,      // Proportional gain
     0.0,    // Integral gain
     0.0        // Derivative gain
    };

    pwmStart(hetRAM1, BLDC_PWM);    // Start Motor Signal
    xTaskNotifyGive(xTaskMASTER);   // Notify Task Master

    for(;;)
    {
        xQueueReceive(xQueue_HX711_CtrlData, &HX711_CtrlData, portMAX_DELAY);       // Await sensor read

        /* ADC BEGIN */
        adcStartConversion(adcREG1, adcGROUP1);
        while(adcIsConversionComplete(adcREG1, adcGROUP1) == 0);
        adcGetData(adcREG1, adcGROUP1, &ADC_CtrlData);
        /* ADC END */

        // Referenced Control
//        ADCMotorThrtt = ((float32) ADC_CtrlData.value) / 4095.0;
//        MotCtrlRef = ((GAUGE_MAX_THRTT - GAUGE_MIN_THRTT) * ADCMotorThrtt) + GAUGE_MIN_THRTT;
//        MotCtrlErr = MotCtrlRef - HX711_CtrlData;
//
//        MotCtrlSignl = (MotCtrlErr / (GAUGE_MAX_THRTT - GAUGE_MIN_THRTT)) * BLDC_PID[Kprop];        // P. compensator

        // TEST CONTROL ONLY
        ADCMotorThrtt = ((float32) ADC_CtrlData.value) / 4095.0;
        MotCtrlSignl = ADCMotorThrtt;

        enhPWMSetDuty(hetRAM1, BLDC_PWM, ((uint32_t) (MotCtrlSignl * 5000.0) + 5000.0));        // Set motor throttle
        xQueueSend(xQueue_CrossChComm_CtrlRef, &ADCMotorThrtt, 0);                              // Send throttle to cross channel

        if(BOARDMODE == BOARD_MAIN)
            xQueueSend(xQueue_SrialComm_CtrlRef, &ADCMotorThrtt, 0);                                // Send throttle telemetry
    }
}

void vTask_CrossCh_Comm(void *pvParameters)
{
    commCtrlData CrossChData;
    ARINC_Frame_Mdata CC_Comm_Mdata_IN,CC_Comm_Mdata_OUT;

    if(BOARDMODE == BOARD_MAIN)
        CC_Comm_Mdata_OUT.SDI = ARINC_SDI_Main;
    else
        CC_Comm_Mdata_OUT.SDI = ARINC_SDI_Backup;

    xTaskNotifyGive(xTaskMASTER);

    for(;;)
    {
        xQueueReceive(xQueue_CrossChComm_HX711, &(CrossChData.HX711_localdata), portMAX_DELAY);         // Wait for local sensor data
        xQueueReceive(xQueue_CrossChComm_CtrlRef, &(CrossChData.CtrlRef_localdata), portMAX_DELAY);     // Wait for local throttle data

        // Exchange sensor data across cross channel
        CC_Comm_Mdata_OUT.SSM = (CrossChData.HX711_localdata >= 0) ? ARINC_SSM_ValuePos : ARINC_SSM_ValueNeg;
        if(BOARDMODE == BOARD_MAIN)
            CC_Comm_Mdata_OUT.LABEL = ARINC_LABEL_MainHX711_data;
        else
            CC_Comm_Mdata_OUT.LABEL = ARINC_LABEL_BackupHX711_data;
        CrossChTransmitandReceiveINT(&CC_Comm_Mdata_IN, &(CrossChData.HX711_CCdata), CC_Comm_Mdata_OUT, CrossChData.HX711_localdata, true);

        // Exchange throttle data accross cross channel
        CC_Comm_Mdata_OUT.SSM = ARINC_SSM_NormOp;
        if(BOARDMODE == BOARD_MAIN)
            CC_Comm_Mdata_OUT.LABEL = ARINC_LABEL_MainCtrlRef;
        else
            CC_Comm_Mdata_OUT.LABEL = ARINC_LABEL_BackupCtrlRef;
        CrossChTransmitandReceiveFLT(&CC_Comm_Mdata_IN, &(CrossChData.CtrlRef_CCdata), CC_Comm_Mdata_OUT, CrossChData.CtrlRef_localdata, 0.0, 1.0);

        // Send cross channel telemetry data
        if(BOARDMODE == BOARD_MAIN)
        {
            xQueueSend(xQueue_SrialComm_HX711, &(CrossChData.HX711_CCdata), 0);
            xQueueSend(xQueue_SrialComm_CtrlRef, &(CrossChData.CtrlRef_CCdata), 0);
        }
    }
}

void vTask_Srial_Comms(void *pvParameters)
{
    int printsize;
    char comm_data_buff[COMM_BUFFER_SIZE];
    commCtrlData RxTxDataBuffer;

    xTaskNotifyGive(xTaskMASTER);

    for(;;)
    {
        // Serial comm task must receive all telemetry data
        xQueueReceive(xQueue_SrialComm_HX711, &(RxTxDataBuffer.HX711_localdata), portMAX_DELAY);
        xQueueReceive(xQueue_SrialComm_HX711, &(RxTxDataBuffer.HX711_CCdata), portMAX_DELAY);
        xQueueReceive(xQueue_SrialComm_CtrlRef, &(RxTxDataBuffer.CtrlRef_localdata), portMAX_DELAY);
        xQueueReceive(xQueue_SrialComm_CtrlRef, &(RxTxDataBuffer.CtrlRef_CCdata), portMAX_DELAY);

        // Format buffer
        printsize = sprintf(comm_data_buff, "/*%d,%d,%.5f,%.5f*/",
                            RxTxDataBuffer.HX711_localdata,
                            RxTxDataBuffer.HX711_CCdata,
                            RxTxDataBuffer.CtrlRef_localdata * 100.0,
                            RxTxDataBuffer.CtrlRef_CCdata * 100.0);

        // SEND DATA
        sciSend(scilinREG, printsize, (uint8_t *) comm_data_buff);
    }
}


void vTask_HX711_Poll(void *pvParameters)
{
    HX711Data_t HX711_dataRead;
    HX711Buff_t HX711_raw;

    /* HX711 POWER DOWN & INIT */
    gioSetBit(PORT_HX711_SCK, PIN_HX711_SCK, 1U);   // Set SCK High
    MPU_vTaskDelay((TickType_t) 1);                 // HX711 Power-off Delay
    // HX711 OFF

    gioEnableNotification(PORT_HX711_DT, PIN_HX711_DT);     // Enable HX711 DT READY IRQ

    // Task master CC sync notifs
    xTaskNotifyGive(xTaskMASTER);
    ulTaskNotifyTake(pdTRUE, portMAX_DELAY);

    gioSetBit(PORT_HX711_SCK, PIN_HX711_SCK, 0U);           // Set SCK Low
    // HX711 ON
    // This line marks the start of normal AS operation

    for(;;)
    {
        xQueueReceive(xQueue_HX711_Raw, &HX711_raw, portMAX_DELAY);     // Wait for raw data
        /* DT IRQ HAS ARRIVED */

        HX711_dataRead = DECODE_TWOS_COMPLEMENT(HX711_raw) - Local_Min_Gauge;   // Decode Sensor data to signed int & trim
        xQueueSend(xQueue_HX711_CtrlData, &HX711_dataRead, 0);                  // Send sensor data to motor control
        xQueueSend(xQueue_CrossChComm_HX711, &HX711_dataRead, 0);               // Send sensor data to cross channel

        gioEnableNotification(PORT_HX711_DT, PIN_HX711_DT);             // Reset DT pin interrupt

        if(BOARDMODE == BOARD_MAIN)
            xQueueSend(xQueue_SrialComm_HX711, &HX711_dataRead, 0);     // Send sensor data to telemetry
    }
}
/* USER TASKS END */

/* IRQ NOTIFICATIONS */
/*
 *  HX711 acquisition happens in Gio IRQ
 */
void gioNotification(gioPORT_t *port, uint32 bit)
{
    BaseType_t xHigherPriorityTaskWoken;

    switch(bit)
    {
    case PIN_HX711_DT:
        HX711_poll_from_GioNotif(&xHigherPriorityTaskWoken, HX711_USER_RES);
        break;
    }

    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}

/* USER CODE END */
