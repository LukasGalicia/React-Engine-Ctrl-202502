/** @file sys_main.c 
*   @brief Application main file
*   @date 11-Dec-2018
*   @version 04.07.01
*
*   This file contains an empty main function,
*   which can be used for the application.
*/

/* 
* Copyright (C) 2009-2018 Texas Instruments Incorporated - www.ti.com 
* 
* 
*  Redistribution and use in source and binary forms, with or without 
*  modification, are permitted provided that the following conditions 
*  are met:
*
*    Redistributions of source code must retain the above copyright 
*    notice, this list of conditions and the following disclaimer.
*
*    Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the 
*    documentation and/or other materials provided with the   
*    distribution.
*
*    Neither the name of Texas Instruments Incorporated nor the names of
*    its contributors may be used to endorse or promote products derived
*    from this software without specific prior written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
*  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
*  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
*  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
*/


/* USER CODE BEGIN (0) */

/* OS INCLUDES */
#include "FreeRTOS.h"
#include "os_task.h"
#include "os_queue.h"

/* HW INCLUDES */
#include "gio.h"
#include "het.h"
#include "adc.h"
#include "spi.h"
#include "sci.h"

/* DRIVER INCLUDES */
#include "projlib/HX711_FREERTOS.h"
#include "projlib/BLDC_ctrlLib.h"
#include "projlib/CROSSCHANNEL.h"
#include "embedded_SCADE/ARINC_INT_ENCDR.h"
#include "embedded_SCADE/ARINC_INT_DCDR.h"

/* USER CODE END */

/* Include Files */

#include "sys_common.h"

/* USER CODE BEGIN (1) */

/* C COMMON INCLUDES */
#include <stdio.h>
#include <stdlib.h>

/* USER DEFINES BEGIN */
#define GAUGE_1_MAX_THRTT   233975
#define GAUGE_1_MIN_THRTT   156838
#define GAUGE_2_MAX_THRTT  -32419
#define GAUGE_2_MIN_THRTT  -108097

#define HX711_USER_RES  HX711_RES_128R_A

enum board_modes
{
    BOARD_BACKUP,       // Backup is 0U
    BOARD_MAIN          // Main is 1U
};
typedef enum board_modes _ECU_MODE;

_ECU_MODE BOARDMODE;
/* USER DEFINES END */

/* USER TASKS BEGIN */
/* TASK MASTER */
void vTaskMASTER(void *pvParameters);
TaskHandle_t xTaskMASTER;

/* HX711 Polling */
void vTask_HX711_Poll(void *pvParameters);
TaskHandle_t xTask_HX711_Poll_Handle;

/* BLDC Control */
void vTask_MotorCtrl(void *pvParameters);
TaskHandle_t xTask_MotorCtrl_Handle;

/* Cross Channel Comm */
void vTask_CrossCh_Comm(void *pvParameters);
TaskHandle_t xTask_CrossCh_Comm;

/* Serial Panel Comm*/
void vTask_Srial_Comms(void *pvParameters);
TaskHandle_t xTask_Srial_Comms;
/* USER TASKS END */

/* USER QUEUES BEGIN */
/* USER QUEUES END */

/* GLOBALS BEGIN */
/* GLOBALS END */

/** @fn     void SCADEInit(void)
 *  @brief  SCADE Models initialization
 *
 */
void SCADEInit( void )
{
    ARINC_INT_ENCDR_init(&CCmsg_FRAME_OUTBOUND);
    ARINC_INT_DCDR_init(&CCmsg_DATA_INBOUND);
}

/* USER CODE END */

/** @fn void main(void)
*   @brief Application main function
*   @note This function is empty by default.
*
*   This function is called after startup.
*   The user can use this function to implement the application.
*/

/* USER CODE BEGIN (2) */
HX711Data_t Local_Min_Gauge = 0xFFFFFFFF;
HX711Data_t Local_Max_Gauge = 0xFFFFFFFF;
/* USER CODE END */

int main(void)
{
/* USER CODE BEGIN (3) */
    /*
     *  Working on branch BLDC_PID
     */

    /* HW Driver Init */
    gioInit();
    hetInit();
    adcInit();
    spiInit();
    sciInit();

    /* Initialize SCADE code */
    SCADEInit();

    /* User Queues CREATE */
    xQueue_HX711_Data = xQueueCreate(1, sizeof(HX711Data_t));           xQueueReset(xQueue_HX711_Data);
    xQueue_HX711_Raw = xQueueCreate(1, sizeof(HX711Buff_t));            xQueueReset(xQueue_HX711_Raw);
    xQueue_SrialComm_HX711 = xQueueCreate(1, 2 * sizeof(HX711Data_t));  xQueueReset(xQueue_SrialComm_HX711);
    xQueue_CrossChComm_HX711 = xQueueCreate(1, sizeof(HX711Data_t));    xQueueReset(xQueue_CrossChComm_HX711);

    /* User Tasks CREATE */
    /* Default TASK MASTER */
    MPU_xTaskCreate(vTaskMASTER,                    // Task Function
                    "Master task",                  // PC Task Name
                    4 * configMINIMAL_STACK_SIZE,   // Memory Stack Size
                    NULL,                           // Task Parameters
                    1,                              // Priority
                    &xTaskMASTER);                  // Task Handler (xTaskHandle)

    /* Scheduler START */
    vTaskStartScheduler();

    for(;;);
/* USER CODE END */

    return 0;
}


/* USER CODE BEGIN (4) */

/* USER TASKS IMP, BEGIN */
void vTaskMASTER(void *pvParameters)
{
    uint8_t CommLABEL, CommSDI, CommSSM;
    int32_t CommDATA;
    char CmdMsgBuff[65];

    /* SYSTEM Init BEGIN */
    BOARDMODE = (gioGetBit(gioPORTA, 4U) == 0U) ? BOARD_BACKUP : BOARD_MAIN;    // Determine if board is MAIN or BACKUP

    if(BOARDMODE == BOARD_BACKUP)                                               // Switch backup MCU's SPI to Slave mode
    {
        /** SPI3 slave mode and clock configuration */
        spiREG3->GCR1 = (spiREG3->GCR1 & 0xFFFFFFFCU) | ((uint32)((uint32)0U << 1U)  /* CLOKMOD */
                      | 0U);  /* MASTER -> slave mode */
    }

    // Master - Backup acknowledge routine
    if(BOARDMODE == BOARD_MAIN)
    {
        sciSend(scilinREG, sprintf(CmdMsgBuff, "Main is waiting for backup acknowledge...\r\n"), (uint8 *) CmdMsgBuff);
        CrossChReceive(&CommLABEL, &CommSDI, &CommDATA, &CommSSM, false);
        if(CommLABEL == ARINC_LABEL_BackupAcknowledge)
            sciSend(scilinREG, sprintf(CmdMsgBuff, "Backup has acknowledged!\r\n"), (uint8 *) CmdMsgBuff);
        else
            while(1);       // BACKUP ACKNOWLEDGE ERROR
    }
    else
    {
        CommLABEL = ARINC_LABEL_BackupAcknowledge;
        CommSDI = ARINC_SDI_Backup;
        CommDATA = ARINC_DATA_DEFAULT;
        CommSSM = ARINC_SSM_FnTest;
        CrossChTransmit(CommLABEL, CommSDI, CommDATA, CommSSM);
    }

    sciSend(scilinREG, sprintf(CmdMsgBuff, "Starting OS\r\n"), (uint8 *) CmdMsgBuff);
    /* SYSTEM Init END */

    /* OS Init BEGIN */
    /* BLDC Controller Task CREATE */
    MPU_xTaskCreate(vTask_MotorCtrl,                // Task Code
                    "BLDC Control Task",            // HL Task Name
                    3 * configMINIMAL_STACK_SIZE,   // Memory Stack Size
                    NULL,                           // Task Parameters
                    4,                              // Priority
                    &xTask_MotorCtrl_Handle);       // Task Handler (xTaskHandle)

    // BLDC Controller Task must notify
    MPU_ulTaskNotifyTake(pdTRUE, portMAX_DELAY);

    /* Cross Channel Comm Task CREATE */
    MPU_xTaskCreate(vTask_CrossCh_Comm,             // Task Code
                    "Cross channel Comms Task",     // HL Task Name
                    3 * configMINIMAL_STACK_SIZE,   // Memory Stack Size
                    NULL,                           // Task Parameters
                    3,                              // Priority
                    &xTask_CrossCh_Comm);            // Task Handler (xTaskHandle)

    // Cross Channel Comm Task must notify
    MPU_ulTaskNotifyTake(pdTRUE, portMAX_DELAY);

    if(BOARDMODE == BOARD_MAIN)     // Only main board transmits serial data
    {
        /* Control panel serial comm Task CREATE */
        MPU_xTaskCreate(vTask_Srial_Comms,              // Task Code
                        "Comm 2 Ctrl Panel Task",       // HL Task Name
                        3 * configMINIMAL_STACK_SIZE,   // Memory Stack Size
                        NULL,                           // Task Parameters
                        2,                              // Priority
                        &xTask_Srial_Comms);            // Task Handler (xTaskHandle)

        // Serial Comm Task must notify
        MPU_ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
    }

    /**
     *  Devices must be synced to begin reading their respecive sensors.
     */

    sciSend(scilinREG, sprintf(CmdMsgBuff, "Syncing devices...\r\n"), (uint8 *) CmdMsgBuff);

    /* HX711 Sensor Handler Task CREATE */
    MPU_xTaskCreate(vTask_HX711_Poll,               // Task Code
                    "HX711 Handler Task",           // HL Task Name
                    3 * configMINIMAL_STACK_SIZE,   // Memory Stack Size
                    NULL,                           // Task Parameters
                    5,                              // Priority
                    &xTask_HX711_Poll_Handle);      // Task Handler (xTaskHandle)

    // HX7111 Task must notify
    MPU_ulTaskNotifyTake(pdTRUE, portMAX_DELAY);

    if(BOARDMODE == BOARD_MAIN)
    {
        CrossChTransmit(ARINC_LABEL_MainHX711ready, ARINC_SDI_Main, ARINC_DATA_DEFAULT, ARINC_SSM_NormOp);
        CrossChReceive(&CommLABEL, &CommSDI, &CommDATA, &CommSSM, false);
        if(CommLABEL == ARINC_LABEL_BackupHX711ready)
            sciSend(scilinREG, sprintf(CmdMsgBuff, "Devices Synced!...\r\n"), (uint8 *) CmdMsgBuff);
        else
            while(1);       // Backup OS init failed
    }
    else
    {
        CrossChReceive(&CommLABEL, &CommSDI, &CommDATA, &CommSSM, false);
        if(CommLABEL == ARINC_LABEL_MainHX711ready)
            CrossChTransmit(ARINC_LABEL_BackupHX711ready, ARINC_SDI_Backup, ARINC_DATA_DEFAULT, ARINC_SSM_NormOp);
        else
            while(1);       // Main OS init failed
    }
    CrossChTransmitandReceive(&CommLABEL, &CommSDI, &CommDATA, &CommSSM, 0b11, 0b00, 0xFFFFFFFF, ARINC_SSM_NormOp, false);
    xTaskNotifyGive(xTask_HX711_Poll_Handle);
    /* OS Init END */

    MPU_vTaskSuspend(NULL);     // Task Master END
}


void vTask_HX711_Poll(void *pvParameters)
{
    HX711Data_t HX711_dataRead;
    HX711Buff_t HX711_raw;

    /* HX711 POWER DOWN & INIT */
    gioSetBit(PORT_HX711_SCK, PIN_HX711_SCK, 1U);   // Set SCK High
    MPU_vTaskDelay((TickType_t) 1);                 // HX711 Power-off Delay
    // HX711 OFF

    gioEnableNotification(PORT_HX711_DT, PIN_HX711_DT);     // Enable HX711 DT READY IRQ

    // Task master CC sync notifs
    xTaskNotifyGive(xTaskMASTER);
    ulTaskNotifyTake(pdTRUE, portMAX_DELAY);

    gioSetBit(PORT_HX711_SCK, PIN_HX711_SCK, 0U);           // Set SCK Low
    // HX711 ON
    // This line marks the start of normal AS operation

    for(;;)
    {
        xQueueReceive(xQueue_HX711_Raw, &HX711_raw, portMAX_DELAY);     // Wait for raw data
        /* DT IRQ HAS ARRIVED */

        HX711_dataRead = DECODE_TWOS_COMPLEMENT(HX711_raw) - Local_Min_Gauge;    // Decode Sensor data to signed int & trim
        xQueueSend(xQueue_HX711_Data, &HX711_dataRead, 0);          // Send sensor data to motor control
        xQueueSend(xQueue_CrossChComm_HX711, &HX711_dataRead, 0);   // Send sensor data to cross channel
        if(BOARDMODE == BOARD_MAIN)
            xQueueSend(xQueue_SrialComm_HX711, &HX711_dataRead, 0);     // Send sensor data to telemetry

        gioEnableNotification(PORT_HX711_DT, PIN_HX711_DT);         // Reset DT pin interrupt
    }
}

void vTask_MotorCtrl(void *pvParameters)
{
    adcData_t ADC_CtrlData;
    HX711Data_t HX711_CtrlData;
    float ADCMotorThrtt;                            // Floating value for Pot-Set Throttle
    float MotCtrlRef, MotCtrlErr, MotCtrlSignl;     // Motor control signals

    /* Preliminary PID */
    float BLDC_PID[3] =
    {
     0.65,      // Proportional gain
     0.0,    // Integral gain
     0.0        // Derivative gain
    };

    pwmStart(hetRAM1, BLDC_PWM);    // Start Motor Signal
    xTaskNotifyGive(xTaskMASTER);   // Notify Task Master

    for(;;)
    {
        xQueueReceive(xQueue_HX711_Data, &HX711_CtrlData, portMAX_DELAY);       // Get Sensor read

        /* ADC BEGIN */
        adcStartConversion(adcREG1, adcGROUP1);
        while(adcIsConversionComplete(adcREG1, adcGROUP1) == 0);
        adcGetData(adcREG1, adcGROUP1, &ADC_CtrlData);
        /* ADC END */

        // Referenced Control
//        ADCMotorThrtt = ((float) ADC_CtrlData.value) / 4095.0;
//        MotCtrlRef = ((GAUGE_MAX_THRTT - GAUGE_MIN_THRTT) * ADCMotorThrtt) + GAUGE_MIN_THRTT;
//        MotCtrlErr = MotCtrlRef - HX711_CtrlData;
//
//        MotCtrlSignl = (MotCtrlErr / (GAUGE_MAX_THRTT - GAUGE_MIN_THRTT)) * BLDC_PID[Kprop];        // P. Compensator

        // TEST CONTROL ONLY
        ADCMotorThrtt = ((float) ADC_CtrlData.value) / 4095.0;
        MotCtrlSignl = ADCMotorThrtt;

        // Set Motor Throttle
        enhPWMSetDuty(hetRAM1, BLDC_PWM, ((uint32_t) (MotCtrlSignl * 5000.0) + 5000.0));
    }
}

void vTask_CrossCh_Comm(void *pvParameters)
{
    HX711Data_t HX711_BoardData, HX711_CCData;
    uint8_t CommLABEL, CommSDI, CommSSM;

    xTaskNotifyGive(xTaskMASTER);

    for(;;)
    {
        xQueueReceive(xQueue_CrossChComm_HX711, &HX711_BoardData, portMAX_DELAY);       // Wait for local sensor data

        // Exchange sensor data across cross channel
        if(BOARDMODE == BOARD_MAIN)
            CrossChTransmitandReceive(&CommLABEL, &CommSDI, &HX711_CCData, &CommSSM,
                                      ARINC_LABEL_MainHX711_data, ARINC_SDI_Main, HX711_BoardData,
                                      (HX711_BoardData > 0) ? ARINC_SSM_ValuePos : ARINC_SSM_ValueNeg,
                                              true);
        else
            CrossChTransmitandReceive(&CommLABEL, &CommSDI, &HX711_CCData, &CommSSM,
                                      ARINC_LABEL_BackupHX711_data, ARINC_SDI_Backup, HX711_BoardData,
                                      (HX711_BoardData > 0) ? ARINC_SSM_ValuePos : ARINC_SSM_ValueNeg,
                                              true);

        // Send cross channel telemetry data
        if(BOARDMODE == BOARD_MAIN)
            xQueueSend(xQueue_SrialComm_HX711, &HX711_CCData, 0);
    }
}

void vTask_Srial_Comms(void *pvParameters)
{
    int printsize;
    char *comm_data_buff;
    commCtrlData RxTxDataBuffer;

    comm_data_buff = (char *) malloc(COMM_BUFFER_SIZE * sizeof(char));       // Allocate buffer size

    xTaskNotifyGive(xTaskMASTER);

    for(;;)
    {
        // Serial comm task must receive all telemetry data
        xQueueReceive(xQueue_SrialComm_HX711, &(RxTxDataBuffer.HX711_localdata), portMAX_DELAY);
        xQueueReceive(xQueue_SrialComm_HX711, &(RxTxDataBuffer.HX711_CCdata), portMAX_DELAY);

        // Format buffer
        printsize = sprintf(comm_data_buff, "/*%d,%d*/", RxTxDataBuffer.HX711_localdata, RxTxDataBuffer.HX711_CCdata);

        // SEND DATA
        sciSend(scilinREG, printsize, (uint8_t *) comm_data_buff);
    }
}
/* USER TASKS END */

/* IRQ NOTIFICATIONS */
/*
 *  HX711 acquisition happens in Gio IRQ
 */
void gioNotification(gioPORT_t *port, uint32 bit)
{
    BaseType_t xHigherPriorityTaskWoken;

    switch(bit)
    {
    case PIN_HX711_DT:
        HX711_poll_from_GioNotif(&xHigherPriorityTaskWoken, HX711_USER_RES);
        break;
    }

    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}

/* USER CODE END */
